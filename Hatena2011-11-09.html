<!DOCTYPE html>
<html lang="en"><head><title>Hatena2011-11-09</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="🪴 Quartz 4.0"/><meta property="og:title" content="Hatena2011-11-09"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Hatena2011-11-09"/><meta name="twitter:description" content="hatena &lt;body> *1320801102*Calculate inner and outer products with numpy ndarray I wondered how to do inner product (v^t v) and matrix product with ndarray's dot method, ..."/><meta property="og:description" content="hatena &lt;body> *1320801102*Calculate inner and outer products with numpy ndarray I wondered how to do inner product (v^t v) and matrix product with ndarray's dot method, ..."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="hatena &lt;body> *1320801102*Calculate inner and outer products with numpy ndarray I wondered how to do inner product (v^t v) and matrix product with ndarray's dot method, ..."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:width" content="1200"/><meta property="og:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https:/quartz.jzhao.xyz/Hatena2011-11-09"/><meta property="twitter:url" content="https:/quartz.jzhao.xyz/Hatena2011-11-09"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="hatena &lt;body> *1320801102*Calculate inner and outer products with numpy ndarray I wondered how to do inner product (v^t v) and matrix product with ndarray's dot method, ..."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Hatena2011-11-09"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href=".">🪴 Quartz 4.0</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>Search</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="./">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Hatena2011-11-09</a></div></nav><h1 class="article-title">Hatena2011-11-09</h1><p show-comma="true" class="content-meta"><span>Nov 09, 2011</span><span>10 min read</span></p></div></div><article class="popover-hint"><p>hatena</p>
<pre><code>&lt;body>
*1320801102*Calculate inner and outer products with numpy ndarray
I wondered how to do inner product (v^t v) and matrix product with ndarray's dot method, but how to do outer product (v v^t)...there is no such method...but then I found a function called &quot;outer&quot;. But then I found a function called &quot;outer&quot;.

>||
In [833]: array([1, 2, 3])
Out[833]: array([1, 2, 3])

In [834]: v = _

In [835]: v.dot(v)
Out[835]: 14

In [836]: outer(v, v)
Out[836]: 
array([[1, 2, 3],
       [2, 4, 6],
       [3, 6, 9]])
||&lt;

*1320801173*numpy to make a diagonal matrix
If you want to create a diagonal matrix such that a given component is in the diagonal component, you can use diag.

>||
In [837]: diag([1, 2, 3])
Out[837]: 
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
||&lt;

*1320801535*NumPy+Matplotlib to color vertices on scatter plots
I was worried about specifying &quot;+&quot; for a marker on a scatter plot and thinking, &quot;Hey, even if I specify a color, it is not reflected...&quot; but the color I specified is used for the marker's fill. +I guess I should have specified &quot;edgecolor&quot;, but I changed the marker to &quot;o&quot; and it looked pretty cool, so I decided to use this one.

[f:id:nishiohirokazu:20111109101621p:image]

Just specify the color of each vertex in the argument c of scatter. In the code below, resp_for_each_data is a two-element vector that sums to 1, so the colors are made by mixing red and green in that ratio.

>||
    red = array([1, 0, 0])
    green = array([0, 1, 0])
    colors = [red * r[0] + green * r[1] for r in resp_for_each_data]
    scatter(data[:, 0], data[:, 1], c=colors, alpha=0.5, marker=&quot;o&quot;)
||&lt;

*1320808028*I implemented k-means method in numpy.
[f:id:nishiohirokazu:20111109120733p:image]

NumPy is amazing. The learning part is practically two lines.
>|python|
# E-step
nearest_cluster = array([argmin([norm(x - mu) for mu in mus]) for x in data])

# M-step
mus = [average(data[nearest_cluster == k], axis=0) for k in range(K)]
||&lt;

&lt;hr>
&lt;a href='http://d.hatena.ne.jp/n_shuyo/20100208/kmeans'>&quot;Pattern Recognition and Machine Learning&quot; (PRML) Reading Group #11 + K-means in R - Mi manca qualche giovedi`? &lt;/a>
>|r|
# 1 step for K-means
(mu &lt;- t(sapply(1:K,function(k)colMeans(xx[max.col(-sapply(1:K,function(i)apply(xx,1,function(x)sum((mu[i,]-x)^2))))==k,]))));
||&lt;

hmm

>|python|
mu = [average(xx[array([argmin([norm(x - m) for m in mu]) for x in xx]) == k], axis=0) for k in range(K)]
||&lt;

All right. (What)

&lt;hr>
I thought that if I increased the number of clusters, they would take one branch at a time, but this happened.

[f:id:nishiohirokazu:20111109124003p:image]

*1320817169*numpy+matplotlib to mark with a cross on a scatter plot
When we say &quot;crossed-out&quot;, there is often an unspoken requirement specification that has not been verbalized. For example, &quot;Do not make the crosses horizontal because they are influenced by the axis of the graph.

[f:id:nishiohirokazu:20111109144009p:image]

In the previous article &quot;&lt;a href='http://d.hatena.ne.jp/nishiohirokazu/20111107/1320660473'>Displaying Mean and Variance on a Scatter Plot with NumPy+Matplotlib&lt;/a>&quot;, I put a Circle in However, this time, I want to use a cross to represent only the center of the clusters, and placing a Circle is not what I expected, as it is affected by the axes and becomes horizontal.

[f:id:nishiohirokazu:20111111000335p:image]

After thinking for a while about what to do, I realized that scatter is fine. The data points on the scatterplot aren't scaled. I wrote them boldly in white and then drew a cross in the color of each cluster in it. It was very easy to achieve.

>||
    clf()
    colors = color_for_cluster[nearest_cluster]
    scatter(data[:, 0], data[:, 1], c=colors, alpha=0.5, marker=&quot;o&quot;)
    scatter(mus[:, 0], mus[:, 1], s=50, linewidths=3, edgecolor=[1, 1, 1], marker=&quot;+&quot;)
    scatter(mus[:, 0], mus[:, 1], s=50, edgecolor=color_for_cluster, marker=&quot;+&quot;)
||&lt;

*1320829189*EM Algorithm Answer Key
I have implemented my code &quot;&lt;a href='http://d.hatena.ne.jp/nishiohirokazu/20111108/1320724692'>I implemented EM algorithm for mixed Gaussian distribution in Numpy&lt;/a>&quot; in Mr. Nakatani's &quot;&lt;a href='http ://d.hatena.ne.jp/n_shuyo/20100304/em_algorithm'>EM Algorithm Implementation (for study) - Mi manca qualche giovedi`? &lt;/a>&quot; and check the answer against it.

First, let's briefly talk about what an EM algorithm is. A situation where, in addition to the observable random variable X, there is also an unobservable random variable Z. In order to represent this situation, you assume some probability model for yourself. You want to choose the best parameter θ of that probability model based on the observed data X. This is the objective. In other words, you want to find θ that maximizes p(X|θ).

Unfortunately, however, the expression for p(X | θ) cannot be easily maximized (if it could, there would be no need to use the EM algorithm). And fortunately, maximizing the log-likelihood ln p(X, Z | θ) of the complete data is easy.

- p(X | θ) cannot be easily maximized, but by Jensen's inequality we can say that it is greater than some expression L(q(Z), θ)
- Stopping θ and maximizing L for q(Z) can be done by setting q to p (E-step), since the remainder is KL(q|||p) if we cull ln p(X|θ), which is unrelated to Z, out of L.
- Stopping q(Z) and maximizing L with respect to θ means that if we cobble together a denominator from L that is irrelevant to θ...er...hmmm...what does the Q function mean? It's the log likelihood of the complete data multiplied by p(Z | X, θ^) and summed over z. Since p(Z | X, θ^) is a coefficient unrelated to θ... hmmm?
- Note: I don't understand how the argmax_theta of the Q function in the M step of the EM algorithm can mean that the log-likelihood of the complete data is differentiated and zero.

It is not my purpose to explain the EM algorithm, so I'll leave it at that (copy and paste) and move on to the source code comparison.

** Data Preparation
>|python|
cls1 = c_[randn(100), randn(100)].dot(array([[10, 0], [0, 1]])).dot(array([[1, -1], [1, 1]]))
cls2 = c_[randn(100), randn(100)].dot(array([[10, 0], [0, 1]])).dot(array([[1, 1], [-1, 1]]))
data = r_[cls1, cls2]
||&lt;
Mr. Nakatani is using Old Faithful data, but I wanted to make sure that data that does not do well with k-means would do well with EM, so I made my own crossed distributions.

** Initialize parameters
>|r|
# of classes
K &lt;- 2;

# Initial values for mean, covariance and mixing ratio (normal random number)
mu &lt;- matrix(rnorm(K*ncol(xx)), nrow=K);
mix &lt;- numeric(K)+1/K;
sig &lt;- list();
for(k in 1:K) sig[[k]] &lt;- diag(ncol(xx));
||&lt;

>|python|
# inital parameter
K = 2
D = 2
mus = [array([1, 1]), array([-1, -1])]
sigmas = [eye(2), eye(2)]
pis = [0.5, 0.5]
assert len(mus) == K and all(len(mu) == D for mu in mus)
assert len(sigmas) == K and all(s.shape == (D, D) for s in sigmas)
assert len(pis) == K
||&lt;
Nakatani-san's is properly made so that the parameters can be changed. Mine was hard-coded. I'll take this opportunity to fix it. Actually, when I implemented k-means, I had to support more than 2 clusters.
>|python|
# inital parameter
K = 2
D = 2
_degrees = array(range(K)) * 2 * pi / K
mus = array([array([sin(th), cos(th)]) for th in _degrees])
sigmas = [eye(D) for k in range(K)]
pis = [1.0 / K] * K
assert len(mus) == K and all(len(mu) == D for mu in mus)
assert len(sigmas) == K and all(s.shape == (D, D) for s in sigmas)
assert len(pis) == K
||&lt;

** Density function of Gaussian distribution
>|r|
# Multidimensional normal distribution density function (use package?)
dmnorm &lt;- function(x,mu,sig) {
	D &lt;- length(mu);
	1/((2 * pi)^D * sqrt(det(sig))) * exp(- t(x-mu) %*% solve(sig) %*% (x-mu) / 2)[1];
}
||&lt;

>|python|
def dens_gauss(x, mu, sigma):
    &quot;&quot;&quot;
    calculate gauss distribution's density
    &quot;&quot;&quot;
    Z = sqrt(2 * pi) ** x.size * sqrt(norm(sigma))
    v = x - mu
    return exp(-0.5 * v.dot(inv(sigma)).dot(v)) / Z
||&lt;

Well, I was going to say it's the same, but it looks like Nakatani's is not square rooted to 2 * pi.

And I should have used det instead of norm on my part.
>||
In [1080]: norm(eye(2))
Out[1080]: 1.4142135623730951

In [1081]: det(eye(2))
Out[1081]: 1.0
||&lt;

** E-step
>|r|
# E-step of the EM algorithm
Estep &lt;- function(xx, mu, sig, mix) {
	K &lt;- nrow(mu);
	t(apply(xx, 1, function(x){
		numer &lt;- sapply(1:K, function(k) {
			mix[k] * dmnorm(x, mu[k,], sig[[k]])
		});
		numer / sum(numer);
	}))
}
||&lt;

>|python|
def resp(x, pis, mus, sigmas):
    &quot;&quot;&quot;
    given: vector x, list of mu, list of sigma
    return: array of responsibility
    eq.9.13
    &quot;&quot;&quot;
    v = array([p * dens_gauss(x, mu, sigma) 
               for p, mu, sigma in zip(pis, mus, sigmas)])
    s = v.sum()
    return v / s

(...snip...)

# E-step
# \gamma(z_nk)
# responsibility
resp_for_each_data = array([resp(x, mus, sigmas) for x in data])
assert len(resp_for_each_data) == N

# eq 9.18, Nk
num_for_each_cluster = array([col.sum() for col in resp_for_each_data.transpose()]) 
assert len(num_for_each_cluster) == K
||&lt;

Almost the same. So Mr. Nakatani wants Nk in the M step.
I guess Numpy has a function to add in column direction. I think Numpy has a function to add in the column direction.
>|r|
N_k &lt;- colSums(gamma_nk);
||&lt;

** M Step
*** π
>|r|
new_mix &lt;- N_k / N;
||&lt;

>|pytohn|
# eq.9.22 update \pi_k
def update_pis(num_for_each_cluster):
    return num_for_each_cluster / N
||&lt;

Well, there's no other way to write it.

*** μ
>|r|
new_mu &lt;- (t(gamma_nk) %*% xx) / N_k;
||&lt;

>|python|
# update parameters, M-step
# eq 9.17, update \mu_k
def update_mus(resp_for_each_data, data, num_for_each_cluster):
    return [
        resp_for_each_data[:, k].dot(data)
        / num_for_each_cluster[k]
        for k in range(K)]
||&lt;

Ah, I see, if you divide by an array of equal lengths, you get element-by-element division. I see. I'll rewrite it.

>||
resp_for_each_data.T.dot(data) / num_for_each_cluster
||&lt;

That, the results are different.

>||
(resp_for_each_data.T.dot(data).T / num_for_each_cluster).T
||&lt;

This would match, but why?

>||
In [1078]: array([[1, 1], [1, 1]]) / array([1.0, 2.0])
Out[1078]: 
array([[ 1. ,  0.5],
       [ 1. ,  0.5]])
||&lt;

Oh, I see. So your interpretation of &quot;if the lengths of the first dimension are the same, then it's element-wise&quot; is wrong, and if the SHAPE is different, then it's broadcast. So if you transpose and then divide, and then transpose the result back, it will be the same as the aircraft, and so on. But I don't like that kind of code, so hmmm, I wonder how to do it elegantly. I'm sure there's a better way to write it, but for now, I'll just write it as a simple zip.

>|python|
array([v / s for v, s in zip(resp_for_each_data.T.dot(data), num_for_each_cluster)])
||&lt;

*** Σ
>||
	new_sig &lt;- list();
	for(k in 1:K) {
		sig &lt;- matrix(numeric(D^2), D);
		for(n in 1:N) {
			x &lt;- xx[n,] - new_mu[k,];
			sig &lt;- sig + gamma_nk[n, k] * (x %*% t(x));
		}
		new_sig[[k]] &lt;- sig / N_k[k]
	}
||&lt;

>|python|
# eq. 9.19, update \Sigma_k
def update_sigmas(resp_for_each_data, data, mus, num_for_each_cluster):
    return [
        array([resp_for_each_data[n, k] 
               * outer(data[n] - mus[k], data[n] - mus[k])
               for n in range(N)]).sum(0)
        / num_for_each_cluster[k] for k in range(K)]
||&lt;

I use sum(0), that is, sum in the direction of the 0th axis, and Nakatani uses &quot;for&quot; to add them together. Instead, I wrote data[n] - mus[k] twice, but Nakatani substitutes x for it, which makes the formula easier to read.

** Summary
It's quite instructive to implement the same content without looking at it and then compare it later. Also, R and Numpy are similar.
&lt;/body>
</code></pre>
<h2 id="hatena-diary-2011-11-09"><a href="https://nishiohirokazu.hatenadiary.org/archive/2011/11/09" class="external">Hatena Diary 2011-11-09<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hatena-diary-2011-11-09" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>This page is auto-translated from <a href="https://scrapbox.io/nishio/Hatena2011-11-09" class="external">/nishio/Hatena2011-11-09<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> using DeepL. If you looks something interesting but the auto-translated English is not good enough to understand it, feel free to let me know at <a href="https://twitter.com/nishio_en" class="external">@nishio_en<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. I’m very happy to spread my thought to non-Japanese readers.</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>