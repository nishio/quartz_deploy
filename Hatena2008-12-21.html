<!DOCTYPE html>
<html lang="en"><head><title>Hatena2008-12-21</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="🪴 Quartz 4.0"/><meta property="og:title" content="Hatena2008-12-21"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Hatena2008-12-21"/><meta name="twitter:description" content="hatena &lt;body> *1229805950*[TopCoder] Single Round Match 430 (Div1/500point) A typical graphing problem in which the coordinates of cities and conditions are given, and ..."/><meta property="og:description" content="hatena &lt;body> *1229805950*[TopCoder] Single Round Match 430 (Div1/500point) A typical graphing problem in which the coordinates of cities and conditions are given, and ..."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="hatena &lt;body> *1229805950*[TopCoder] Single Round Match 430 (Div1/500point) A typical graphing problem in which the coordinates of cities and conditions are given, and ..."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:width" content="1200"/><meta property="og:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https:/quartz.jzhao.xyz/Hatena2008-12-21"/><meta property="twitter:url" content="https:/quartz.jzhao.xyz/Hatena2008-12-21"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="hatena &lt;body> *1229805950*[TopCoder] Single Round Match 430 (Div1/500point) A typical graphing problem in which the coordinates of cities and conditions are given, and ..."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Hatena2008-12-21"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href=".">🪴 Quartz 4.0</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>Search</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="./">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Hatena2008-12-21</a></div></nav><h1 class="article-title">Hatena2008-12-21</h1><p show-comma="true" class="content-meta"><span>Dec 21, 2008</span><span>11 min read</span></p></div></div><article class="popover-hint"><p>hatena</p>
<pre><code>&lt;body>
*1229805950*[TopCoder] Single Round Match 430 (Div1/500point)
A typical graphing problem in which the coordinates of cities and conditions are given, and the goal is to create as many pairs (a &quot;sister city&quot; relationship between two cities) as possible that satisfy the conditions. The two conditions are that the cities must be at least minDistance apart and that a city can be sister to at most maxPartner cities. The other condition is to choose the one with the shortest total distance among several ways of making pairs that maximize the number of pairs.

The maximum number of cities is 10 and the maximum maxPartner is 3, so the maximum number of possible pairings is 45 and the maximum number of pairs is 15. I tried to find out if it would be okay to search the whole area and still be able to do a good job of trimming branches.

>|cpp|
class TwinTowns {
public:
  int MAX_EDGES;
  size_t N;
  vector&lt;pair&lt;int, int> > edges;
  vector&lt;int> edgesLen;
  size_t NUM_EDGES;
  int MAX_PARTNERS;
  int resultDist;
  int resultEdges;

  void recur(size_t i, int numEdges, int dist, vector&lt;int>&amp; degree){
    int v0 = edges[i].first;
    int v1 = edges[i].second;
    if(degree[v0] == MAX_PARTNERS || degree[v1] == MAX_PARTNERS){
      // can't add the edge
      return;
    }
    numEdges++;
    dist += edgesLen[i];
    if(dist > resultDist &amp;&amp; numEdges &lt;= resultEdges){
      // too distant
      return;
    }
    if(numEdges > resultEdges){
      resultEdges = numEdges;
      resultDist = dist;
    }else if(numEdges == resultEdges &amp;&amp; dist &lt; resultDist){
      resultDist = dist;
    }
    if(numEdges &lt; MAX_EDGES){
      degree[v0]++;
      degree[v1]++;
      // enough room to add edge
      for(size_t j=i+1; j&lt;NUM_EDGES; j++){
	recur(j, numEdges, dist, degree);
      }
      degree[v0]--;
      degree[v1]--;
    }
  }
  vector &lt;int> optimalTwinTowns(vector &lt;int> x, vector &lt;int> y, int maxPartners, int minDistance) {
    N = x.size();
    MAX_PARTNERS = maxPartners; 
    edges.clear();
    edgesLen.clear();

    for(size_t i=0; i&lt;N; i++){
      for(size_t j=i+1; j&lt;N; j++){
        int len = abs(x[i] - x[j]) + abs(y[i] - y[j]);
	if(len >= minDistance){
	  edges.push_back(make_pair(i, j));
	  edgesLen.push_back(len);
	}
      }
    }
    NUM_EDGES = edges.size();
    vector&lt;int> degree(N);
    MAX_EDGES = N * maxPartners / 2;
    resultEdges = 0;
    resultDist = 2000 * 100; // infinity
    vector&lt;int> result;
    for(size_t i=0; i&lt;NUM_EDGES; i++){
      recur(i, 0, 0, degree);
    }
    result.push_back(resultEdges);
    result.push_back(resultDist);
    return result;
  }
}
||&lt;

It passed the system test in a short enough time, so I SUBMIT it.
>|cpp|
    if(dist > resultDist &amp;&amp; numEdges &lt;= resultEdges){
      // too distant
      return;
    }
||&lt;
It's a no-go. This is pruning too many branches because the resultEdges may be smaller than the correct answer if the correct answer has not yet been found. On the other hand, commenting this out would normally result in a timeout. Now, what is the right thing to do?

I kept a record of the number of ranks and the shortest I've ever had at that rank, and used that to prune branches.
>|cpp|
class TwinTowns {
public:
  size_t N;
  vector&lt;pair&lt;int, int> > edges;
  vector&lt;int> edgesLen;
  size_t NUM_EDGES;
  int MAX_PARTNERS;
  int resultDist;
  int resultEdges;
  vector&lt;int> cache;

  int getDegree(int deg, int i){
    return (deg >> (i * 2)) &amp; 3;
  }
  int setDegree(int deg, int i, int v){
    return (deg &amp; ~(3 &lt;&lt; (i * 2))) | (v &lt;&lt; (i * 2));
  }

  void recur(size_t i, int numEdges, int dist, int degree){
    int v0 = edges[i].first;
    int v1 = edges[i].second;
    if(getDegree(degree, v0) == MAX_PARTNERS || getDegree(degree, v1) == MAX_PARTNERS){
      // can't add the edge
      return;
    }
    numEdges++;
    dist += edgesLen[i];
    if(numEdges > resultEdges){
      resultEdges = numEdges;
      resultDist = dist;
    }else if(numEdges == resultEdges &amp;&amp; dist &lt; resultDist){
      resultDist = dist;
    }

    degree = setDegree(degree, v0, getDegree(degree, v0) + 1);
    degree = setDegree(degree, v1, getDegree(degree, v1) + 1);
    if(cache[degree] == 0 || dist &lt;= cache[degree]){
      // add edge
      cache[degree] = dist;
      for(size_t j=i+1; j&lt;NUM_EDGES; j++){
	recur(j, numEdges, dist, degree);
      }
    }

  }
  vector &lt;int> optimalTwinTowns(vector &lt;int> x, vector &lt;int> y, int maxPartners, int minDistance) {
    N = x.size();
    MAX_PARTNERS = maxPartners; 
    edges.clear();
    edgesLen.clear();
    cache.clear();
    cache.resize(1 &lt;&lt; (2 * N));
    for(size_t i=0; i&lt;N; i++){
      for(size_t j=i+1; j&lt;N; j++){
        int len = abs(x[i] - x[j]) + abs(y[i] - y[j]);
	if(len >= minDistance){
	  edges.push_back(make_pair(i, j));
	  edgesLen.push_back(len);
	}
      }
    }
    NUM_EDGES = edges.size();
    resultEdges = 0;
    resultDist = 0;
    for(size_t i=0; i&lt;NUM_EDGES; i++){
      recur(i, 0, 0, 0);
    }
    vector&lt;int> result;
    result.push_back(resultEdges);
    result.push_back(resultDist);
    return result;
  }
}
||&lt;

result
>||
Args:
{{851, 33, 108, 369, 127, 778, 434, 88, 873, 246}, {646, 532, 395, 134, 364, 276, 72, 592, 628, 249}, 3, 649}

Expected:
{14, 12205}

Received:
{14, 12325}
||&lt;
Hmmm.

*1229824697*CUDA Diary 1
Thread sync is per block. Shared memory in each block is as fast as a register. Threads that need to cooperate should be in the same block.

I recognized from GPU Gems that GPUPUs have difficulty with scatter (random access write), so the algorithm needs to be devised, but the advantage of CUDA seems to be that it makes this possible.

Kernel execution is asynchronous, but Memcpy, which retrieves the results, waits for kernel execution, so it looked like it was processing synchronously.

Only __device__ memory can be tampered with from the host. The latency of __device__ is high. It is hundreds of times larger than __shared__. If we are going to do table lookups, it would be foolish to leave it in __device__, so should we copy it to __shared__? Or should we embed it in the kernel? Of course there may be a limit to the size of the kernel. I guess it depends on the size of the table and the amount of access.

Variables declared in the kernel without any modifiers will be __shared__. However, arrays of size 5 or larger become __device__.

There are &quot;vector types&quot; such as int4. Will these add up in parallel if I add them, for example? I'll try later.

There's such a thing as cudaMemcpyAsync.

-----

So I wrote a code that searches for all the best moves in the last turn of the last round of the game. I have not yet verified if the result is correct because I just tried to get it to the point where it works without error, but when I run it, it returns the result -1, 23, 3 with time = 10232. Even when I play, I get 5 in the middle on this surface, so I wonder if it's right! The speed only uses one block and the problem is too small to be interesting, so I'll try to get it to read through the entire final round and then compare it to the code in C++.

Oh, you forgot to leave out the x == y case for now.

>|cpp|
#include &lt;stdio.h>
#include &lt;stdlib.h>

#include &lt;cutil.h>
#define NUM_BLOCKS    1

__device__ static int calc_median(int v0, int v1, int v2){
    if(v1 &lt; v2){
    	if(v2 &lt; v0){
	    return v2;
	}else if(v0 &lt; v1){
	    return v1;
	}else{
	    return v0;
	}
    }else{
    	if(v1 &lt; v0){
	    return v1;
	}else if(v0 &lt; v2){
	    return v2;
	}else{
	    return v0;
	}
    }
}

__global__ static void kernel(const int * input, int * output, clock_t * timer)
{
    __shared__ int shared[3 * 7 * 7];

    const int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;
    const int bid = blockIdx.x;
    const int tid = x + y * 7 + z * 7 * 7;
    if (tid == 0) timer[bid] = clock();
    
    // update round score
    int buf[] = {input[10], input[11], input[12]};
    int my=input[z], o1=input[3 + x], o2=input[3 + y];
    int median = calc_median(my, o1, o2);
    if(my == median) buf[0] += median / 4 + 1;
    if(o1 == median) buf[1] += median / 4 + 1;
    if(o2 == median) buf[2] += median / 4 + 1;
    
    // update game score
    median = calc_median(buf[0], buf[1], buf[2]);
    o1 = buf[1]; o2 = buf[2]; my = buf[0];
    buf[0] = input[13]; // game score
    buf[1] = input[14];
    buf[2] = input[15];
    if(my == median) buf[0] += median;
    if(o1 == median) buf[1] += median;
    if(o2 == median) buf[2] += median;

    // find winner
    o1 = buf[1]; o2 = buf[2]; my = buf[0];
    median = calc_median(buf[0], buf[1], buf[2]);
    int win = 0;
    if(my == median) win += 2;
    if(o1 == median) win--;
    if(o2 == median) win--;
    
    shared[tid] = win;

    __syncthreads();
    if(x == 0){
        int sum = 0;
    	for(int i=0; i &lt; 7; i++){
	    sum += shared[tid + 7 * i];
	}
	shared[tid] = sum;
    }
    __syncthreads();
    if(x == 0 &amp;&amp; y == 0){
        int sum = 0;
    	for(int i=0; i &lt; 7; i++){
	    sum += shared[tid + i];
	}
	output[z] = sum;
    }
    __syncthreads();
    if (tid == 0) timer[bid+gridDim.x] = clock();
}

int main(int argc, char** argv)
{
    CUT_DEVICE_INIT();

    int * dinput = NULL;
    int * doutput = NULL;
    clock_t * dtimer = NULL;

    clock_t timer[NUM_BLOCKS * 2];
    int input[] = {
    	1, 5, 13, // own cards
    	4, 15, 6, 7, 8, 9, 10, // others cards
	0, 5, 0, // round score
	0, 5, 0}; // game score

    CUDA_SAFE_CALL(cudaMalloc((void**)&amp;dinput, sizeof(int) * 16));
    CUDA_SAFE_CALL(cudaMalloc((void**)&amp;doutput, sizeof(int) * 3));
    CUDA_SAFE_CALL(cudaMalloc((void**)&amp;dtimer, sizeof(clock_t) * NUM_BLOCKS * 2));

    CUDA_SAFE_CALL(cudaMemcpy(dinput, input, sizeof(int) * 16, cudaMemcpyHostToDevice));

    dim3 THREADS(7, 7, 3);
    kernel&lt;&lt;&lt;NUM_BLOCKS, THREADS>>>(dinput, doutput, dtimer);

    int output[3];
    CUDA_SAFE_CALL(cudaMemcpy(output, doutput, sizeof(int) * 3, cudaMemcpyDeviceToHost));
    CUDA_SAFE_CALL(cudaMemcpy(timer, dtimer, sizeof(clock_t) * NUM_BLOCKS * 2, cudaMemcpyDeviceToHost));

    CUDA_SAFE_CALL(cudaFree(dinput));
    CUDA_SAFE_CALL(cudaFree(doutput));
    CUDA_SAFE_CALL(cudaFree(dtimer));

    clock_t minStart = timer[0];
    clock_t maxEnd = timer[NUM_BLOCKS];

    for (int i = 1; i &lt; NUM_BLOCKS; i++)
    {
        minStart = timer[i] &lt; minStart ? timer[i] : minStart;
        maxEnd = timer[NUM_BLOCKS+i] > maxEnd ? timer[NUM_BLOCKS+i] : maxEnd;
    }

    printf(&quot;time = %d\n&quot;, maxEnd - minStart);
    printf(&quot;%d, %d, %d\n&quot;, output[0], output[1], output[2]);
    CUT_EXIT(argc, argv);
}
||&lt;

*1229825420*Vim Diary
C-n for dynamic abbreviation completion, :s/... for substitution /... /g for dynamic abbreviation completion, :%s/... /... /... /gc

*1229836965* Information board
I would be happy if more stations had something like this.
f:id:nishiohirokazu:20081221142244j:image

*1229854217*Sunlight
It was a nice day, so I went to Tobu Zoo station for no particular reason. tobu zoo flies when you read the Roman alphabet!

*1229880372*[Mid-term] long time no see
I rewrote it a bit based on the discussion in &lt;a href='http://d.hatena.ne.jp/nishiohirokazu/20081101/1225517718'>I noticed &lt;/a>.
>|cpp|
class Cards{
public:
  Cards(vector&lt;int> xs):
    values(xs),len(xs.size()){}
  inline int pop(size_t i){
    len--;
    swap(values[i], values[len]);
    return values[len];
  }
  inline void revert(size_t i){
    swap(values[i], values[len]);
    len++;
  }
  vector&lt;int> values;
  size_t len;
};
||&lt;
The behavior may be obvious, but just for the sake of testing, I will post the output results.
>||
  DP(hands.values);
  DP(hands.pop(2));
  DP(hands.values);
  hands.revert(2);
  DP(hands.values);
Output under ----
hands.values: {4, 14, 15, 17, 49}
hands.pop(2): 15
hands.values: {4, 14, 49, 17, 15}
hands.values: {4, 14, 15, 17, 49}
||&lt;
This is used to use the same card array from start to finish.


I also simplified the core part and combined it into a single function.
>|cpp|
Result turn(const int iturn, Cards&amp; unknowns, Cards &amp;hand, 
		   const scores &amp;round_score, const scores &amp;game_score){

  Result result;
  size_t N = unknowns.len;
  
  for(size_t myi=0; myi&lt;hand.len; myi++){
    int my = hand.pop(myi);
    eval_value score = 0;

    for(size_t i=0; i &lt; N; i++){
      int o1 = unknowns.pop(i);
      for(size_t j=0; j &lt; N - 1; j++){
	if(i == j) continue;
	int o2 = unknowns.pop(j);
	if(iturn == 3){
	  score += end_of_game(
	    end_of_round(
	      end_of_turn(my, o1, o2, round_score), 
	      game_score));
	  
	}else{
	  score += turn(
	    iturn + 1,
	    unknowns, hand,
	    end_of_turn(my, o1, o2, round_score),
	    game_score).score;
	}
	unknowns.revert(j);
      }
      unknowns.revert(i);
    }
    if(score > result.score){
      result.score = score;
      result.hand = my;
    }

    hand.revert(myi);
  }
  return result;
}
||&lt;

Oh, it takes 9.9 seconds to run. It takes about 4.2 seconds with the older version.
http://coderepos.org/share/browser/lang/python/saichugen/experiments/cpp/saichugen_simple.cpp?rev=27176
Hmmm...I think I'm making a big mistake if I'm twice as slow as I should be.
&lt;/body>
&lt;comments>
&lt;comment>
&lt;username>tgbt&lt;/username>
&lt;body>The old GPGPUs could not do a write->read sequence to the GPU's shared memory during a single drawing pass, but CUDA makes it easier and more comfortable. &lt;BR>&lt;BR>Well, in short, I was desperate because I only had Texture. &lt;BR>&lt;BR>Threads within the same block cannot perform different types of operations at the same time, so it's important to make it SIMD-like, GlobalMemory is certainly slower, but whether the difference is actually 100 times greater is another matter, and if you want to draw tables, just go for ConstantMemory. If you want to draw a table, ConstantMemory is the way to go. I haven't been doing CUDA programming lately for some reason! &lt;/body>
&lt;timestamp>1229866391&lt;/timestamp>
&lt;/comment>
&lt;/comments>
</code></pre>
<h2 id="hatena-diary-2008-12-21"><a href="https://nishiohirokazu.hatenadiary.org/archive/2008/12/21" class="external">Hatena Diary 2008-12-21<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hatena-diary-2008-12-21" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>This page is auto-translated from <a href="https://scrapbox.io/nishio/Hatena2008-12-21" class="external">/nishio/Hatena2008-12-21<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> using DeepL. If you looks something interesting but the auto-translated English is not good enough to understand it, feel free to let me know at <a href="https://twitter.com/nishio_en" class="external">@nishio_en<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. I’m very happy to spread my thought to non-Japanese readers.</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>