<!DOCTYPE html>
<html lang="en"><head><title>Hatena2008-06-26</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="🪴 Quartz 4.0"/><meta property="og:title" content="Hatena2008-06-26"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Hatena2008-06-26"/><meta name="twitter:description" content="hatena &lt;body> *1214442108*It's so...cold! It was my fault for thinking it was summer and sleeping with the windows open and only a terrycloth blanket ..."/><meta property="og:description" content="hatena &lt;body> *1214442108*It's so...cold! It was my fault for thinking it was summer and sleeping with the windows open and only a terrycloth blanket ..."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="hatena &lt;body> *1214442108*It's so...cold! It was my fault for thinking it was summer and sleeping with the windows open and only a terrycloth blanket ..."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:width" content="1200"/><meta property="og:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https:/quartz.jzhao.xyz/Hatena2008-06-26"/><meta property="twitter:url" content="https:/quartz.jzhao.xyz/Hatena2008-06-26"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="hatena &lt;body> *1214442108*It's so...cold! It was my fault for thinking it was summer and sleeping with the windows open and only a terrycloth blanket ..."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Hatena2008-06-26"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href=".">🪴 Quartz 4.0</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>Search</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="./">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Hatena2008-06-26</a></div></nav><h1 class="article-title">Hatena2008-06-26</h1><p show-comma="true" class="content-meta"><span>Jun 26, 2008</span><span>12 min read</span></p></div></div><article class="popover-hint"><p>hatena</p>
<pre><code>&lt;body>
*1214442108*It's so...cold!

It was my fault for thinking it was summer and sleeping with the windows open and only a terrycloth blanket.

*1214483990* Python spa starting tomorrow.
http://www.hosen.co.jp/A11_3.htm#3

It looks like &quot;Yonemiya,&quot; doesn't it? I was in tears when the transfer guide said &quot;there is no such station&quot;!

>||
■Oshigami
｜ Subway Toei Asakusa Line (Nishimagome bound) 7.8km Cars No. 3 and 6
｜ 09:33～09:49 [16 min.]
｜ 210 yen
Shinbashi [7 min. wait].
｜ JR Tokaido Main Line (East Japan) (to Atami) 4.9km
｜ 09:56-10:00 [4 min.]
｜ 1,890 yen
Shinagawa [7 min. wait].
｜ Limited Express Odoriko No.107 (to Izukyu Shimoda) 99.0km
｜ 10:07-11:26 [79 min.]
｜ Reserved seat 1,410 yen
■Coming to the palace
||&lt;

I'm going to go with this, but it may be later.

*1214499822*[TopCoder]Single Round Match 407
It's been quite a while and I forgot C++ orz
I wondered how to write it, but I didn't have time to look it up, so I wrote it in a foolish for statement.


Now, after participating in TopCoder, I learn to write explanations of the problem statements, while exposing the code I wrote in the matches, and fixing it nicely until I am satisfied (for me).

&lt;img src=&quot;http://gyazo.com/5dbf57896a0b240e6f1ac3021192b572.png&quot;>

The first problem I solved this time was a 500-point problem. The question was, &quot;Find the total salary of all employees since the salary of an employee with no subordinates is 1, the salary of an employee with subordinates is the sum of the subordinates' salaries, and the salary of an employee who has subordinates gives information on who is subordinate to whom.&quot; Since the size of the number of employees is small enough, I thought it would be OK to calculate &quot;Mr. A's salary is the sum of his subordinates' salaries&quot; as it is in the recurrence call.

>|cpp|
class CorporationSalary {
public:
  vector&lt;string> gxs;
  vector&lt;long long> salary;
  long long totalSalary(vector &lt;string> xs) {
    size_t N = xs.size();
    gxs = xs;
    salary = vector&lt;long long>(N);
    long long total = 0LL;
    for(size_t i=0; i&lt;N; i++){
      total += calc(i);
    }
    return total;
  }

  long long calc(size_t i){
    if(salary[i] != 0) return salary[i];
    size_t N = gxs.size();
    long long sum = 0LL;
    bool has_child = false;
    for(size_t j=0; j&lt;N; j++){
      if(gxs[i][j] == 'Y'){
	sum += calc(j);
	has_child = true;
      }
    }
    if(has_child){
      salary[i] = sum;
      return sum;
    }else{
      salary[i] = 1;
      return 1;
    }
  }
}
||&lt;

I'll try to rewrite it a bit.

>|cpp|
typedef long long LL;
class CorporationSalary {
public:
  LL totalSalary(vector &lt;string> relations) {
    N = relations.size();
    relations_ = relations;
    salary = vector&lt;LL>(N);
    LL total = 0LL;
    for(size_t i=0; i&lt;N; i++){
      total += calc(i);
    }
    return total;
  }
private:
  size_t N;
  vector&lt;string> relations_;
  vector&lt;LL> salary;
  LL calc(size_t i){
    // already calc'ed
    if(salary[i] != 0) return salary[i];

    LL sum = 0LL;
    bool has_child = false;
    for(size_t j=0; j&lt;N; j++){
      if(relations_[i][j] == 'Y'){
	sum += calc(j);
	has_child = true;
      }
    }
    if(has_child){
      salary[i] = sum;
      return sum;
    }else{
      salary[i] = 1;
      return 1;
    }
  }
}
||&lt;

What I didn't like initially was that I copied the &quot;employee relationship&quot; argument into a public field. At first I thought &quot;shared_ptr!&quot; and then I tried to pass it by reference because I didn't have time to look it up, and I wasn't sure of the syntax either way.

For example, in the code below, the copy constructor is called twice.
>|cpp|
class MyValue {
public:
  MyValue(){
    cout &lt;&lt; &quot;cstr&quot; &lt;&lt; endl;
  }
  MyValue(const MyValue &amp;x){
    cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;
  }
  ~MyValue(){
    cout &lt;&lt; &quot;dstr&quot; &lt;&lt; endl;
  }
};

class MyClass {
public:
  void foo(MyValue x){
    bar(x);
  }
private:
  void bar(MyValue x){
    
  }
};

int main(){
  MyValue v;
  MyClass c;
  c.foo(v);
}
||&lt;

I can't help it as long as the game rules say &quot;vector&lt;int> is passed by value&quot; at least once, but I don't want to be foolish enough to copy it every time when I call it again and again after that.

>|diff|
 private:
-   void bar(MyValue x){
+   void bar(MyValue &amp;x){
     
   }
||&lt;

Now it is no longer copied. I'm happy and satisfied.

>|diff|
 private:
-   void bar(MyValue &amp;x){
+   void bar(const MyValue &amp;x){
     
   }
||&lt;

This time I put const because I know it won't be changed. I think it is better to do this when writing the actual code. If I make a mistake and try to change it, the compiler will get mad at me. Konosuke Matsushita is said to have said, &quot;It is nice to be angry, and if you are unhappy about being angry, it is a waste of time, so I will not get angry.


Okay, so far we've reviewed what we've studied before. I want to use boost::shared_ptr. I think it makes for better code. http://www.kmonos.net/alang/boost/classes/shared_ptr.html

>|cpp|
typedef boost::shared_ptr&lt;MyValue> MyValuePtr;
class MyClass {
public:
  void foo(MyValue x){
    p = MyValuePtr(&amp;x);
    bar();
  }
private:
  MyValuePtr p;
  void bar(){
    
  }
};
-----
Execution Result
cstr
copy
dstr
dstr
a.out(5453) malloc: *** error for object 0xbffff9df: Non-aligned pointer being freed
*** set a breakpoint in malloc_error_break to debug
dstr
||&lt;

Oops, no. I see... the way it's written, it's free when it leaves the scope of foo, and then it's free again when it leaves the scope of main and c is freed. I mean, if it doesn't have to be a smart pointer, why not just use a regular pointer?

>|cpp|
class MyValue {
public:
  MyValue():v(42){
    cout &lt;&lt; &quot;cstr&quot; &lt;&lt; endl;
  }
  MyValue(const MyValue &amp;x):v(x.v){
    cout &lt;&lt; &quot;copy&quot; &lt;&lt; endl;
  }
  ~MyValue(){
    cout &lt;&lt; &quot;dstr&quot; &lt;&lt; endl;
  }
  int v;
};


class MyClass {
public:
  void foo(MyValue x){
    p = &amp;x;
    bar();
  }
private:
  MyValue *p;
  void bar(){
    cout &lt;&lt; (*p).v &lt;&lt; endl;
  }
};
-----
output (result)
cstr
copy
42
dstr
dstr
||&lt;

What the heck, that's all right. The fact that this doesn't come out easily shows how little I understand pointers.


System testing is over.
&lt;img src=&quot;http://gyazo.com/c315efc97bece408b04cbea9ead89dfc.png&quot;>
Even though none of us ended up solving it, it was frustrating to have someone shoot down a 1,000-point problem.

Now, leaving aside the rewriting of the answers to the 500-point questions with pointers, the next question is the 1000-point question.
There is a long, narrow corridor-like series of squares that costs money to pass through, with two rules. Find out the cheapest way to get from one end to the other with the fewest number of moves, and answer the pair of least cost and least number of moves. There may be no answer. Rule 1: Each square has a &quot;square price. One can proceed to the next square by paying the price. However, if the price of a square is -1, it is forbidden to enter. Rule 2: There are several warp gates on the map. If a person is in a square that has an entrance to a warp gate, he or she can warp to the exit. When they do so, they must pay a warp fee. The warp fee goes up by 1 for each warp. In this case, you cannot enter the -1 square.&quot;
I tried to explain it in a concise way, peeling away the rigor, but still, here's what it looks like.


First, the code as posted.
>|cpp|
class CheapestRoute {
public:
  vector &lt;int> routePrice(vector &lt;int> cellPrice, vector &lt;int> enterCell, vector &lt;int> exitCell, int teleportPrice) {
    vector&lt;int> position;
    position.push_back(0);
    vector&lt;int> cost;
    cost.push_back(0);
    vector&lt;int> num_warp;
    num_warp.push_back(0);

    vector&lt;int> candidate_step;
    vector&lt;int> candidate_cost;
    vector&lt;int> next_pos;
    vector&lt;int> next_cost;
    vector&lt;int> next_warp;
    int min_cost = 1 &lt;&lt; 30;
    cout &lt;&lt; min_cost &lt;&lt; endl;

    size_t N = cellPrice.size();
    size_t GOAL = N - 1;
    cout &lt;&lt; &quot;GOAL:&quot; &lt;&lt; GOAL  &lt;&lt; endl;
    int step = 0;
    while(!position.empty()){
      //cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl;
      for(size_t i=0; i &lt; position.size(); i++){
	int p = position[i];
	int c = cost[i];
	//	cout &lt;&lt; &quot;p:&quot; &lt;&lt; p &lt;&lt; &quot;c:&quot; &lt;&lt; c  &lt;&lt; endl;
	if(p == GOAL){
	  candidate_cost.push_back(c);
	  candidate_step.push_back(step);
	  if(c &lt; min_cost){
	    min_cost = c;
	  }
	  continue;
	}
	if(c >= min_cost) continue;

	// if next cell is not -1, you can walk into it
	if(cellPrice[p + 1] != -1){
	  next_pos.push_back(p + 1);
	  next_cost.push_back(c + cellPrice[p + 1]);
	  next_warp.push_back(num_warp[i]);
	}
	
	// if you can enter
	int exit = 0;
	for(size_t j=0; j &lt; enterCell.size(); j++){
	  if(enterCell[j] == p){
	    exit = exitCell[j];
	    if(cellPrice[exit] == -1) continue;
	    int w = num_warp[i];
	    next_pos.push_back(exit);
	    next_cost.push_back(c + teleportPrice + w);
	    next_warp.push_back(w + 1);
	  }
	}

      }
      position = next_pos;
      cost = next_cost;
      num_warp = next_warp;
      next_pos.clear();
      next_cost.clear();
      next_warp.clear();
      step++;
    }

    cout &lt;&lt; &quot;hoge&quot; &lt;&lt; endl;
    vector&lt;int> result;
    if(candidate_step.empty()) return result;
    cout &lt;&lt; candidate_step[0] &lt;&lt; endl;
    int min_step = 1 &lt;&lt; 30;
    for(size_t i=0; i&lt;candidate_step.size(); i++){
      int c = candidate_cost[i];
      int s = candidate_step[i];
      //cout &lt;&lt; c &lt;&lt; &quot;, &quot;;
      //cout &lt;&lt; s &lt;&lt; endl;
      if(c == min_cost){
	if(s &lt; min_step){
	  min_step = s;
	}
      }
    }
    result.push_back(min_cost);
    result.push_back(min_step);
    return result;
  }
}
||&lt;

Ah, Anzai-sensei, I want to use tuples... Ruby's struct is OK, so I'll use struct for now... I mean, I'll try to use class.

>|cpp|
class State {
public:
  State():position(0),cost(0),warp(0){}
  size_t position;
  int cost;
  int warp;
};

class Candidate {
public:
  int step;
  int cost;
};

class CheapestRoute {
public:
  vector &lt;int> routePrice(vector &lt;int> cellPrice, vector &lt;int> enterCell, vector &lt;int> exitCell, int teleportPrice) {
    State start;
    vector&lt;State> states;
    states.push_back(start);
    vector&lt;State> next_states;
    vector&lt;Candidate> candidates;

    int min_cost = 1 &lt;&lt; 30;
    size_t N = cellPrice.size();
    size_t GOAL = N - 1;

    int step = 0;
    while(!states.empty()){
      for(size_t i=0; i &lt; states.size(); i++){
	State cur(states[i]);
	size_t p = cur.position;
	int c = cur.cost;
	if(p == GOAL){
	  Candidate cand;
	  cand.cost = c;
	  cand.step = step;
	  if(c &lt; min_cost){
	    min_cost = c;
	  }
	  candidates.push_back(cand);
	  continue;
	}
	if(c >= min_cost) continue;

	// if next cell is not -1, you can walk into it
	if(cellPrice[p + 1] != -1){
	  State next(cur);
	  next.position++;
	  next.cost += cellPrice[p + 1];
	  next_states.push_back(next);
	}
	
	// if you can enter
	int exit = 0;
	for(size_t j=0; j &lt; enterCell.size(); j++){
	  if(enterCell[j] == p){
	    exit = exitCell[j];
	    if(cellPrice[exit] == -1) continue;
	    State next(cur);
	    next.position = exit;
	    next.cost += teleportPrice + cur.warp;
	    next.warp++;
	    next_states.push_back(next);
	  }
	}

      }
      states = next_states;
      next_states.clear();
      step++;
    }

    vector&lt;int> result;
    if(candidates.empty()) return result;
    int min_step = 1 &lt;&lt; 30;
    for(size_t i=0; i&lt;candidates.size(); i++){
      int c = candidates[i].cost;
      int s = candidates[i].step;
      if(c == min_cost){
	if(s &lt; min_step){
	  min_step = s;
	}
      }
    }
    result.push_back(min_cost);
    result.push_back(min_step);
    return result;
  }
}
||&lt;

It's much easier to read. I don't see the point of having classes if everything is public, though.


I also think that 1 &lt;&lt; 30 is too much, so

>|cpp|
#define __STDC_LIMIT_MACROS
#include&lt;iostream>
using namespace std;

#include&lt;boost/cstdint.hpp>
(omitted)
using namespace boost;


(omitted)
    int32_t min_cost = INT32_MAX;
||&lt;

I didn't know that #define __STDC_LIMIT_MACROS was required to use INT32_MAX.


Then also use boost/assign.
>|diff|
-    result.push_back(min_cost);
-    result.push_back(min_step);
+    result += min_cost, min_step;
||&lt;

If I assign it, it will be copied and it will be a waste, so I'll try to make it swap.
>|diff|
-      states = next_states;
+      states.swap(next_states);
||&lt;

This is another useless copy. What shall we do?
>|cpp|
for(size_t i=0; i &lt; states.size(); i++){
  State cur(states[i]);
||&lt;

Like this?
>|cpp|
for(vector&lt;State>::iterator cur = states.begin(), end = states.end(); cur != end; ++i){
||&lt;

No, I can't turn it into an iterator because I'll need i when I do the warp calculations later.

>|cpp|
for(size_t i=0; i &lt; states.size(); i++){
  State *cur = &amp;(states[i]);
  size_t p = cur->position;
  int c = cur->cost;
||&lt;

I wonder if it's like this. I feel like &amp;(states[i]) is a bit too wild.


Oh, my rating has been updated...I only solved one question but it went up.
&lt;img src=&quot;http://gyazo.com/48964bc9e3c28891941a1d0ec22ad6ea.png&quot;>

-----

Now, why did the 1000 point problem FAIL?
First, input something like this: {0, 0, -1}, {0, 1}, {1, 0}, and if the goal is reached, the score is used to footnote the goal, but if the problem cannot be reached, as in this example, it continues to warp and loop infinitely. If a cell can be reached at cost n, there is no need to search ahead even if it is reached by a method with cost greater than n. Because it can't be the least cost. Is that really true? No, it's not. The cost of warp changes depending on the number of times you warp, so it's not a simple matter of saying that. For example, let's say the last step is a path that can only be reached by warp, and the cost of warp is 0, and the cost of warp is 4 if you walk, and 3 times if you warp. The correct answer is to walk and fly at cost 0, not to fly 4 times. Hmmm, that's a tough one.

In the meantime, let's try to make it CONTINUE if both the cost and the number of warps are greater than before and see if it passes the test.

Nope, it still falls one. And the trap is that the minimum cost I answered is wrong. It's a case of trimming too much when you trim the upper branches, I'm sure. Hmmm, what could be wrong?
&lt;/body>
&lt;comments>
&lt;comment>
&lt;username>poohtarou&lt;/username>
&lt;body>Although I am from Shizuoka, I had never heard of Raikyu station...........................orz&lt;/body>.
&lt;timestamp>1214547325&lt;/timestamp>
&lt;/comment>
&lt;/comments>
</code></pre>
<h2 id="hatena-diary-2008-06-26"><a href="https://nishiohirokazu.hatenadiary.org/archive/2008/06/26" class="external">Hatena Diary 2008-06-26<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hatena-diary-2008-06-26" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>This page is auto-translated from <a href="https://scrapbox.io/nishio/Hatena2008-06-26" class="external">/nishio/Hatena2008-06-26<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> using DeepL. If you looks something interesting but the auto-translated English is not good enough to understand it, feel free to let me know at <a href="https://twitter.com/nishio_en" class="external">@nishio_en<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. I’m very happy to spread my thought to non-Japanese readers.</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>