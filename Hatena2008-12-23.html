<!DOCTYPE html>
<html lang="en"><head><title>Hatena2008-12-23</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="ü™¥ Quartz 4.0"/><meta property="og:title" content="Hatena2008-12-23"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Hatena2008-12-23"/><meta name="twitter:description" content="hatena &lt;body> *1229985164* CUDA Diary 2: Morning return from year-end party Yesterday I wrote about &quot;parallel reduction of an array of N elements that is not a power of ..."/><meta property="og:description" content="hatena &lt;body> *1229985164* CUDA Diary 2: Morning return from year-end party Yesterday I wrote about &quot;parallel reduction of an array of N elements that is not a power of ..."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="hatena &lt;body> *1229985164* CUDA Diary 2: Morning return from year-end party Yesterday I wrote about &quot;parallel reduction of an array of N elements that is not a power of ..."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:width" content="1200"/><meta property="og:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https:/quartz.jzhao.xyz/Hatena2008-12-23"/><meta property="twitter:url" content="https:/quartz.jzhao.xyz/Hatena2008-12-23"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="hatena &lt;body> *1229985164* CUDA Diary 2: Morning return from year-end party Yesterday I wrote about &quot;parallel reduction of an array of N elements that is not a power of ..."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Hatena2008-12-23"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href=".">ü™¥ Quartz 4.0</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>Search</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="./">Home</a><p> ‚ùØ </p></div><div class="breadcrumb-element"><a href>Hatena2008-12-23</a></div></nav><h1 class="article-title">Hatena2008-12-23</h1><p show-comma="true" class="content-meta"><span>Dec 23, 2008</span><span>12 min read</span></p></div></div><article class="popover-hint"><p>hatena</p>
<pre><code>&lt;body>
*1229985164* CUDA Diary 2: Morning return from year-end party
Yesterday I wrote about &quot;parallel reduction of an array of N elements that is not a power of 2. Since all I want to do is to sum up the list, a simple method is to fill in the missing parts to the power of 2 with zeros. If N has only 2 or 3 prime factors, I think the third method is fine, but if N has 7 or more prime factors, what is the fastest way to do it?

I want to think about the &quot;what if&quot; but I'm still sleepy, so I'm going to go to bed for a bit. I've consumed caffeine, so if I set the timer for 30-60 minutes later, my blood caffeine level should be at its highest.

-----

It would be nice to see what the CUDA code looks like in the instruction sequence and how it is processed.

From reading the documentation, I'm thinking that if A and B are completely different processes in the code below, it would only take 1 second on a CPU, but 2 seconds on a GPU. I'll give it a try.
>||
if(x &amp; 1){ // if odd
  // Process A, which takes 1 second
}else{
  // Process B that takes 1 second
}
||&lt;

-----

I wrote the code to check. 64 threads. 1 block. The difference is one line, so I wrote it in diff style.

>|cpp|
const int LOOP_SIZE = 1000000;
__global__ static void kernel(const int* input, int* output, clock_t * timer) {
    const int x = threadIdx.x;
    const int bid = blockIdx.x;
    if (x == 0) timer[bid] = clock();

    int v = 0;

-    if(x &amp; 1){
+    if(x &lt; 32){
      for(int i=0; i &lt; LOOP_SIZE; i++){
        v += i;
      }
    }else{
      for(int i=LOOP_SIZE; i > 0; i--){
        v -= i;
      }
    }
    output[x] = v;
    __syncthreads();
    if (x == 0) timer[bid+gridDim.x] = clock();
}
||&lt;

>||
Result of (x &amp; 1)
time = 148000468
time = 148000468
time = 148000468

(x &lt; 32) results in
time = 86000420
time = 86000404
time = 86000420
||&lt;

The expectation was that the performance difference would be nearly double, but I don't understand why the 148 and 86 are not neatly doubled. I wonder why.

*1230022340*CUDA Diary (Bank Conflict experiment)
The number of consumed clocks is like 86000420 because the process I want to measure is calculated 1 mega iteration. So I decided to write it as 86M without worrying about fractions.

I wanted to make sure Bank Conflict happens, so this is the kind of code I used. The number of threads is 4.
From the code around the iteration of v += i;, we can see that the cost of the for statement itself is 60M, so the cost of v += smem[x * 2]; is 16M, and the cost of smem[x] += smem[0]; is 36M, more than double.

>|cpp|
const int LOOP_SIZE = 1000000;
__global__ static void kernel(const int* input, int* output, clock_t * timer) {
    const int x = threadIdx.x;
    const int bid = blockIdx.x;
    __shared__ int smem[16];

    if (x == 0) timer[bid] = clock();
    int v = 0;
    for(int i=0; i &lt; LOOP_SIZE; i++){
      //smem[x] += smem[0]; // 96M
      smem[x * 2] += smem[0]; // 80M
      //smem[x] += smem[x + 4]; // 88M
      //smem[x * 2] += smem[x * 2 + 1]; // 80M 
      //v += smem[x * 2]; // 76M
      //v += smem[x]; // 80M
      //v += i; // 80M
      //v += i; v += i; // 100M
      //v += i; v += i; v += i;// 120M
      //v += i + smem[x * 2]; // 80M
    }
    output[x] = v; //smem[x];
    __syncthreads();
    if (x == 0) timer[bid+gridDim.x] = clock();
}
||&lt;

I read that shared memory is as fast as a register as long as BankConflict doesn't occur, but as there are only 4 threads, i must be in the register. But if there are only 4 threads, the i's should be in the registers. Oh, I guess not. I'm not sure if the compiler is smart enough to rewrite the code to get it outside the loop and add a constant, since smem[x * 2] is a constant for the duration of the loop, and if you empty the contents of the for statement, it will delete the entire for statement and replace it with a constant.
>||
      //v += smem[x * 2]; // 76M
      //v += smem[x]; // 80M
      //v += i; // 80M
||&lt;

The cost saved by changing the method of memory access is about one-fifth of v += i;, so I thought I shouldn't worry about it unless it is a &quot;process with crazy low calculation density&quot; like reduction or simply multiplying an array by n.

*1230031948*vim diary (delle period)
I'm starting to understand the advantages of vim. In an environment where I can customize it freely, I think, &quot;This is so much more complicated than emacs,&quot; or &quot;If it were emacs, it would automatically detect all normal languages and indent them appropriately from the beginning,&quot; but now that I am using Knoppix, I am using vim I'm using vim because I'm on Knoppix and it's too much trouble to customize it. I haven't messed with .vimrc.

When I want to add to the end of a line, it's easy to use A without having to move to the end of the line. It would be better if you put it right before the semicolon, but I guess $bi.
Moving in search is also useful, though I haven't mastered it yet. /1&lt;Enter> to move to the next one. I think there was something that didn't require Enter, but I forget. If you want to rewrite 48 to 72, you can use cw to delete the word and enter insert mode.
I'm sure emacs had rectangular selection, but I don't remember. vim is easy to remember because v is for selection, V for line selection, and &lt;CTRL-v> for rectangular selection.
The default auto-indent feature is poor, so I do 4i&lt;SPACE>&lt;ESC> to put four spaces, but I wonder if there is a better way.

*1230032780*else in preprocessor if
I thought it was #else if like C, but it was #elif, same as Python. Of course, Python came later, but was C the first to use elif? I wonder if C was the first to use elif, or if there was an earlier language that used elif and they copied it.

*1230033942*CUDA Diary (parallel reduction experiment for arrays that are not powers of 2)
The question is whether it is faster to calculate the sum of an array with 72 elements by filling in up to 128 with zeros and then doing the normal two-by-two reduction, or whether it is faster to factorize and reduce by some 3 or something like that. As it turns out, dividing by 3 first was about 10% faster than the type that fills up to 128.

I also tried the 42 case, but it was only a 5% speedup with 580 reduced to 551. 42 is subtle because of the 7 in the prime factors.

I just realized that if we use 72 * 2 (144) instead of 128 to fill with zero, we don't need __syncthreads(). I also need __syncthreads() after smem[x] = x;.


>|cpp|
#define N 72
#define NUM_BLOCKS 1
#define CEIL 128
#define TYPE 0

const int LOOP_SIZE = 1000000;
__global__ static void kernel(const int* input, int* output, clock_t * timer) {
    const int x = threadIdx.x;
    const int bid = blockIdx.x;
    __shared__ int smem[CEIL];

    if (x == 0) timer[bid] = clock();
    for(int i=0; i &lt; LOOP_SIZE; i++){
#if TYPE == 0
      // 684M
      // zero reset
      smem[CEIL - N + x] = 0;
      __syncthreads();

      // target values
      smem[x] = x;

      // reduction
      if(x &lt; 64){
      	smem[x] += smem[x + 64];
      }
      __syncthreads();
      if(x &lt; 32){
        smem[x] += smem[x + 32];
        smem[x] += smem[x + 16];
        smem[x] += smem[x + 8];
        smem[x] += smem[x + 4];
        smem[x] += smem[x + 2];
        smem[x] += smem[x + 1];
      }
#elif TYPE == 1
      // 632M
      // target values
      smem[x] = x;

      // reduction
      if(x &lt; 36){
        smem[x] += smem[x + 36];
      }
      __syncthreads();
      if(x &lt; 18){
        smem[x] += smem[x + 18];
	smem[x] += smem[x + 9];
	smem[x] += smem[x + 3] + smem[x + 6];
	smem[x] += smem[x + 1] + smem[x + 2];
      }
#else
      // 624M
      // target values
      smem[x] = x;

      // reduction
      if(x &lt; 24){
        smem[x] += smem[x + 24] + smem[x + 48];
      }
      __syncthreads();
      if(x &lt; 8){
        smem[x] += smem[x + 8] + smem[x + 16];
	smem[x] += smem[x + 4];
	smem[x] += smem[x + 2];
	smem[x] += smem[x + 1];
      }
#endif
      if(x == 0) output[0] = smem[0];
    }
    __syncthreads();
    if (x == 0) timer[bid+gridDim.x] = clock();
}
||&lt;

*1230039090* Too much to do.
I'm going back to my parents' house on 27 or 8, so there's only so much I can do.

If o1 &lt; o2 is known, then calc_median would only need two if statements. Might it also make it easier to predict branching?

If the card array is expressed in a structure that allows deletion and restoration while preserving order, it may be possible to further speed up the process while retaining the current advantage of not requiring a copy. Is there such a data structure? Since it is known that no additions will occur, we can create a linked list as an array.

This can be done with a MacBook, so let's do it while I'm back at my parents' house.

Next, we used OpenCV and a USB camera to recognize images of playing cards. It's a hassle to carry around a camera, but if you save the images from the camera locally, you can just bring your Thinkpad back to your parents' house.

I have to do it in my room because my room is not reacheable from outside. I can develop on MacBook with an emulator, but I don't think it will be popular.

I knew CUDA was the top priority!

*1230042229*Goolang
Since there was no GPUPU when Erlang was born, Google should just make a new Erlang-like VM. They should also make the hardware. They should also create a language. And call it Goolang!

*1230047914*vim-rogue
As you advance through the dungeon, a monster appears, and the monster presents you with the string before and after the rewrite, and you can defeat the monster when you finish the rewrite. It is important to rewrite quickly as hit points decrease with time.

You can buy a magic book at the magic shop in town, and when you read it, it has vim commands, but of course if you don't use them, you forget them (literally).

There are various status abnormalities; for example, the blind status abnormality makes it impossible to see the text being typed. The pious status abnormality is a beginner's curse because it prevents the use of the cursor keys, but advanced users can intentionally cause a status abnormality by wearing a &quot;ring of piety&quot; because it has the effect of lowering the time consumption when moving.

The heavier the load, the slower the key repeat. More in-game time is also consumed. In-game time is basically proportional to the number of keys struck. However, meta keys have an additional cost. The vim command can be used to move around the map.

I hope someone will make a game that is like that!

*1230057212*CUDA Diary 3
Shared memory is said to be equivalent to L1 cache. Global memory is not cached, so it explicitly caches itself if necessary. It takes only 4 clocks to tell it to read from global memory, but there is a latency of 400 to 600 clocks before the data is actually sent. If there are a sufficient number of independent processes in the meantime, they can do that, thus hiding the latency.

What I wrote in the first entry today, about how unlike CPUs, branching takes time for both, was properly written in the cuda programming guide.

The unit of the value returned by the clock function is &quot;the value of a per-multiprocessor counter that is incremented every clock cycle&quot;. So, which clock is it, the core clock of 600 MHz or the shader clock of 1500 MHz? Am I right in understanding that it is the shader clock?

If so, the readout for the last turn of the middle limit is about 12,000 clocks, so the entire last round would be 1.3 seconds. If we parallelize the code well, it will be 14 times faster than the C++ code, which is 0.09 seconds. Well, if you look at the speedups of other computational processes, I guess that's about right. I still wish it was an order of magnitude faster. I wonder if I can make it an order of magnitude faster if I work hard.

>||
>>> 12000 * 4 * 9 * 8 * 5 * 11 * 10 / 1500000000.0
1.2672000000000001
>>> _ / 14
0.090514285714285728
||&lt;
&lt;/body>
&lt;comments>
&lt;comment>
&lt;username>hoge&lt;/username>
&lt;body>If you have a choice, there is also vip. &lt;/body>
&lt;timestamp>1230032720&lt;/timestamp>
&lt;/comment>
&lt;comment>
&lt;username>earth2001y&lt;/username>
&lt;body>sh is elif&lt;/body>.
&lt;timestamp>1230038224&lt;/timestamp>
&lt;/comment>
&lt;comment>
&lt;username>Dubhead&lt;/username>
&lt;body>>> Auto indent function&lt;br>I'm not sure, are you talking about CTRL-T / CTRL-D while in input mode? &lt;br>:he i_CTRL-T reference. &lt;/body>
&lt;timestamp>1230091570&lt;/timestamp>
&lt;/comment>
&lt;/comments>
</code></pre>
<h2 id="hatena-diary-2008-12-23"><a href="https://nishiohirokazu.hatenadiary.org/archive/2008/12/23" class="external">Hatena Diary 2008-12-23<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#hatena-diary-2008-12-23" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>This page is auto-translated from <a href="https://scrapbox.io/nishio/Hatena2008-12-23" class="external">/nishio/Hatena2008-12-23<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> using DeepL. If you looks something interesting but the auto-translated English is not good enough to understand it, feel free to let me know at <a href="https://twitter.com/nishio_en" class="external">@nishio_en<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. I‚Äôm very happy to spread my thought to non-Japanese readers.</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li>No backlinks found</li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> ¬© 2024</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="./postscript.js" type="module"></script></html>